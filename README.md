# sBox

Run programs in a sandbox environment without writting to rootfs.


## Description:

Programs run in **sBox** still have access to your rootfs except all modifications to file system will be cached. You may chose to merge these changes on exit.

In addition, each sandbox have its own network stack(has internet access), mount points, process info, ipc, uts, and cgroup.

It's more like a stripped down version of docker.

## Usage: 

Run program in sandbox

```bash
sbox [-n|--container-name NAME] [-r|--user-root USER] [-d|--snapshot-dir DIR] [-h|--help] PROGRAM
```

e.g.,

```bash
# run apt in a privileged sandbox
sbox apt update

# run apt in a un-privileged sandbox, with mapping to user1
sbox -r user1 bash
```

* **-n | --container-name NAME**
    
    Name of the sandbox.\
    For identification purpose. Essential if you want to send another program into the sandbox. \
    Default value is 'default'.

* **-r | --user-root USER** 
    
    Still need root to mount.\
    Enable user namespace.\
    Will drop root privileges to user `USER` right before entering *user namespace* so that sandbox will be bound by `USER`'s privilege.\
    Finally, map `USER`'s uid to root inside sandbox.

* **-d | --snapshot-dir DIR** 

    Path of the snapshot directory storing **commited** file system changes after program exit from sandbox.\
    
    
* **-h | --help**

    Display help information.

## Note:

- sBox use `OverlayFS` as the "storage engine" (docker jargon ><). Files generated by your program will be cached at `/tmp/sbox/CONTAINER NAME/dirty`. Upon ***commit***, these files will be move to `SNAPSHOT DIR` overriding any existing one.

- Can not map current user to arbitary user in sandbox. Mapping is no longer do-able using pure shell script because newer kernel doesn't allow updating uid_map/gid_map after 'execve'[(\*)](https://stackoverflow.com/questions/45972426/unshare-user-namespace-and-set-uid-mapping-with-newuidmap).

- If `-r USER` is not set, sBox will not create custom *user namespace*, so all other namespaces will be children of the namespace the invoking process is in(e.g., shell's user namespace). Do not set this flag if custom *user namespace* breaks your program. On the other hand, if this flag is set, all other namespaces will be children to the newly created *user namespace*.
