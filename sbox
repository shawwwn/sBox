#!/bin/bash
#
# sbox
# Run programs in a sandbox environment without writting to rootfs.
#
# This program is NOT a full-fledge container like docker!
# Instead, it is a cut-down version of container, namely a sandbox, designed 
# to allow you to run programs without worrying about polluting your rootfs.
# You may chose to merge the files generated by your program into rootfs 
# once it exits.
# Will run on any platform that can run docker.
#
# Copyright: 2019 Shawwwn, shawwwn1@gmail.com
# License: MIT
#
# Usage: sbox [-n|--container-name NAME] [-r|--user-root] [-d|--snapshot-dir DIR] [-h|--help] PROGRAM
#
CONTAINER_NAME=default					# default container name
SNAPSHOT_DIR="snapshot"					# default snapshot directory name

USER_NAMESPACE=""
USER="root"
PREFIX_DIR="/sbox"

function help {
	echo "usage: $0: [-n|--container-name NAME] [-r|--user-root USER] [-d|--snapshot-dir DIR] [-h|--help] PROGRAM"
	echo ""
	echo "Run programs in a sandbox environment without writting to rootfs."
	echo ""
	echo "	-n	Mount OverlayFS at /tmp/sbox/<NAME>."
	echo "		Default cantainer name is 'default'."
	echo ""
	echo "	-r	Create user namespace as unprivileged user <USER>,"
	echo "		so that its privileges will be bound by the user."
	echo ""
	echo "	-d	Directory to store files generated by sandboxed program."
	echo "		Default location is /tmp/sbox/<NAME>/snapshot."
	echo "		You can specify the <DIR> to disk if you want to save generated files."
	echo ""
	echo "	-h	..."
}

function cleanup {
	#echo 'cleaning up'
	if mountpoint -q "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"; then
		umount "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"
	fi
}
trap cleanup EXIT
trap "ret=$?; cleanup; exit $ret" INT QUIT TERM HUP
set -m # job control


# transform long options to short ones
for arg in "$@"; do
	shift
	case "$arg" in
		"--container-name") set -- "$@" "-n" ;;
		"--user-root")      set -- "$@" "-r" ;;
		"--snapshot-dir")   set -- "$@" "-d" ;;
		"--help")           set -- "$@" "-h" ;;
		*)                  set -- "$@" "$arg"
	esac
done


# process options
OPTIND=1
while getopts n:r:d:h opt; do
	case $opt in
		n)                  CONTAINER_NAME=$OPTARG ;;
		r)                  USER_NAMESPACE="--user --map-root-user"
		                    USER=$OPTARG ;;
		d)                  SNAPSHOT_DIR=$OPTARG ;;
		h)                  help
		                    exit ;;
		?)                  help
		                    exit 2 ;;
	esac
done
shift $(expr $OPTIND - 1)


# check root
if [ $(id -u) -ne 0 ]; then
	echo "need to run as root"
	exit 2
fi


# check positional arguments
if [ -z "$1" ]; then
	echo "nothing to run!" && help && exit 2
fi


echo "container name: \"$CONTAINER_NAME\""
cleanup # clean up last execution (if any)
mkdir "/tmp$PREFIX_DIR" >/dev/null 2>&1
pushd "/tmp$PREFIX_DIR" >/dev/null

# create/load rootfs
mkdir -p "$CONTAINER_NAME/dirty" >/dev/null 2>&1
mkdir -p "$CONTAINER_NAME/workdir" >/dev/null 2>&1
mkdir -p "$CONTAINER_NAME/rootfs" >/dev/null 2>&1
cd "$CONTAINER_NAME" # /tmp/sbox/$CONTAINER_NAME
SNAPSHOT_DIR=$(realpath "$SNAPSHOT_DIR") # resolve to abs path
if [ ! -d "$SNAPSHOT_DIR" ]; then
	mkdir -p "$SNAPSHOT_DIR" >/dev/null 2>&1 # create snapshot directory
else
	echo "load previous snapshot for \"$CONTAINER_NAME\""
fi

# mount rootfs via overlayfs
# [/] -> [snapshot_dir] -> [dirty] <= file i/o
mount -t overlay \
	-o lowerdir="$SNAPSHOT_DIR":/,upperdir="dirty",workdir="workdir" \
	overlay "rootfs"

# remove symlink if found
if [ ! -z "\$(readlink rootfs/etc/resolv.conf)" ]; then
	rm rootfs/etc/resolv.conf
	touch rootfs/etc/resolv.conf
fi
popd >/dev/null


# prep sandbox network
eth_setup() {
	P1=$1
	P2=$2
	ip link add "veth_$CONTAINER_NAME" type veth peer name veth0 # create pair eth
	ip addr add 192.168.50.1/30 dev "veth_$CONTAINER_NAME" # 192.168.50.1 - 192.168.50.2
	ip link set "veth_$CONTAINER_NAME" up

	iptables -t nat -A POSTROUTING -s 192.168.50.1/30 -o eth0 -j MASQUERADE # 192.168.50.1 - 192.168.50.2
	iptables -A FORWARD -i eth0 -o "veth_$CONTAINER_NAME" -j ACCEPT
	iptables -A FORWARD -o eth0 -i "veth_$CONTAINER_NAME" -j ACCEPT

	read unshare_pid <$P1 # wait for sandbox pid
	rm $P1
	if [ ! -n "$unshare_pid" ] || [ ! "$unshare_pid" -eq "$unshare_pid" ] 2>/dev/null; then
		echo "Error: Network setup failed -- unable to get unshare pid!" >&2
		exit 1
	fi
	echo "sandbox pid: $unshare_pid"
	mkdir -p "/var/run/netns" >/dev/null 2>&1
	touch "/var/run/netns/ns_$CONTAINER_NAME"
	mount --bind "/proc/$unshare_pid/ns/net" "/var/run/netns/ns_$CONTAINER_NAME"
	ip link set veth0 netns "ns_$CONTAINER_NAME" # send veth0 to sandbox
	ip netns exec "ns_$CONTAINER_NAME" ip addr add 192.168.50.2/30 dev veth0 # 192.168.50.1 - 192.168.50.2
	ip netns exec "ns_$CONTAINER_NAME" ip link set veth0 up
	ip netns exec "ns_$CONTAINER_NAME" ip link set lo up
	ip netns exec "ns_$CONTAINER_NAME" ip route add default via 192.168.50.1 # route all traffic to go through veth0
	umount "/var/run/netns/ns_$CONTAINER_NAME"
	rm "/var/run/netns/ns_$CONTAINER_NAME"
	echo "eth_setup() exit" >$P2 # signal main process that we are done
}

PIPE1=$(mktemp -u) # for receiving namespace pid in task
PIPE2=$(mktemp -u) # for receiving task finish signal 
sudo -u $USER mkfifo $PIPE1 $PIPE2
echo "eth_setup() start"
(eth_setup $PIPE1 $PIPE2 &) # async


# create new namespace
sudo -u $USER \
unshare --mount --propagation slave \
	--pid --uts --ipc --cgroup 	--net\
	--kill-child $USER_NAMESPACE \
	--fork \
	bash -c """$(cat <<-EOF
		# send current shell pid to background task
		cat /proc/self/status | grep ^PPid: | awk '{print \$2}' >$PIPE1
		
		# wait for background task to complete (optional)
		read str <$PIPE2
		echo "\$str"
		rm $PIPE2

		# mountings
		cd "/tmp$PREFIX_DIR/$CONTAINER_NAME"
		mount -t proc proc rootfs/proc
		mount -t tmpfs tmpfs rootfs/tmp
		mount -t sysfs -r sysfs rootfs/sys
		# mount --rbind -r /sys rootfs/sys # mount if net ns is not present
		mount --rbind /dev rootfs/dev # -r ?
		mount -t tmpfs tmpfs rootfs/run
		# mount --rbind -r /run rootfs/run # this or resolv.conf
		mount --bind \$(readlink -f /etc/resolv.conf) rootfs/etc/resolv.conf

		# display extra info if enters user namespace
		user_inode=$(readlink /proc/self/ns/user | cut -c7-16) # user ns
		if [ ! -z "$USER_NAMESPACE" ]; then
			echo "new user ns: \$user_inode"
			echo "as user: \$USER(\$(id -u \$USER))"
		fi

		echo "Enter container \"$CONTAINER_NAME\": "

		exec chroot rootfs \
			bash -c 'cd ~; exec $@'
		echo "Error: program shouldn't reach here." >&2
		EOF
	)"""


# release netns
iptables -t nat -D POSTROUTING -s 192.168.50.1/30 -o eth0 -j MASQUERADE # 192.168.50.1 - 192.168.50.2
iptables -D FORWARD -i eth0 -o "veth_$CONTAINER_NAME" -j ACCEPT
iptables -D FORWARD -o eth0 -i "veth_$CONTAINER_NAME" -j ACCEPT
ip link delete "veth_$CONTAINER_NAME" >/dev/null 2>&1
cleanup
trap - EXIT # free trap

#TODO: save snapshot

jobs
echo "done!"

