#!/bin/bash
#
# sBox
# Run programs in a sandbox environment without writting to rootfs.
#
# This program is NOT a full-fledge container like docker!
# Instead, it is a cut-down version of container, namely a sandbox, designed 
# to allow you to run programs without worrying about polluting your rootfs.
# You may chose to merge the files generated by your program into rootfs 
# once it exits.
# Will run on any platform that can run docker.
#
# Copyright: 2019 Shawwwn, shawwwn1@gmail.com
# License: MIT
#
# Usage: sbox [-n|--container-name NAME] [-r|--user-root] [-d|--snapshot-dir DIR] [-h|--help] PROGRAM
#

CONTAINER_NAME=default					# default container name
SNAPSHOT_DIR="snapshot"					# default snapshot directory name

USER_NAMESPACE=""
USER="root"
PREFIX_DIR="/sbox"

function help {
	echo "usage: $0: [-n|--container-name NAME] [-r|--user-root USER] [-d|--snapshot-dir DIR] [-h|--help] PROGRAM"
	echo ""
	echo "Run programs in a sandbox environment without writting to rootfs."
	echo ""
	echo "	-n	Mount OverlayFS at /tmp/sbox/<NAME>."
	echo "		Default cantainer name is 'default'."
	echo ""
	echo "	-r	Create user namespace as unprivileged user <USER>,"
	echo "		so that its privileges will be bound by the user."
	echo ""
	echo "	-d	Directory to store files generated by sandboxed program."
	echo "		Default location is /tmp/sbox/<NAME>/snapshot."
	echo "		You can specify the <DIR> to disk if you want to save generated files."
	echo ""
	echo "	-h	..."
}

function cleanup {
	#echo 'cleaning up'
	if mountpoint -q "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"; then
		umount "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"
	fi
}
trap cleanup EXIT
trap "ret=$?; cleanup; exit $ret" INT QUIT TERM HUP



# transform long options to short ones
for arg in "$@"; do
	shift
	case "$arg" in
		"--container-name") set -- "$@" "-n" ;;
		"--user-root")      set -- "$@" "-r" ;;
		"--snapshot-dir")   set -- "$@" "-d" ;;
		"--help")           set -- "$@" "-h" ;;
		*)                  set -- "$@" "$arg"
	esac
done


# process options
OPTIND=1
while getopts n:r:d:h opt; do
	case $opt in
		n)                  CONTAINER_NAME=$OPTARG ;;
		r)                  USER_NAMESPACE="--user --map-root-user"
		                    USER=$OPTARG ;;
		d)                  SNAPSHOT_DIR=$OPTARG ;;
		h)                  help
		                    exit ;;
		?)                  help
		                    exit 2 ;;
	esac
done
shift $(expr $OPTIND - 1)


# check root
if [ $(id -u) -ne 0 ]; then
	echo "need to run as root"
	exit 2
fi


# check positional arguments
if [ -z "$1" ]; then
	echo "nothing to run!" && help && exit 2
fi


echo "container name: \"$CONTAINER_NAME\""
cleanup # clean up last execution (if any)
[ ! -d "/tmp$PREFIX_DIR" ] && mkdir "/tmp$PREFIX_DIR"
pushd "/tmp$PREFIX_DIR" > /dev/null

# create/load rootfs
if [ ! -d "$CONTAINER_NAME" ]; then
	echo "create rootfs for \"$CONTAINER_NAME\""
	mkdir "$CONTAINER_NAME"
	cd "$CONTAINER_NAME"
	mkdir dirty workdir rootfs
else
	echo "load previous rootfs for \"$CONTAINER_NAME\""
	cd "$CONTAINER_NAME"
fi
SNAPSHOT_DIR=$(realpath "$SNAPSHOT_DIR") # resolve to abs path
[ ! -d "$SNAPSHOT_DIR" ] && mkdir "$SNAPSHOT_DIR" # create snapshot directory
cd ..

# mount rootfs via overlayfs
# [/] -> [snapshot_dir] -> [dirty] <= file i/o
mount -t overlay \
	-o lowerdir="$SNAPSHOT_DIR":/,upperdir="$CONTAINER_NAME/dirty",workdir="$CONTAINER_NAME/workdir" \
	overlay "$CONTAINER_NAME/rootfs"
popd > /dev/null

# remove symlink if found
pushd "/tmp$PREFIX_DIR/$CONTAINER_NAME" >/dev/null
if [ ! -z "\$(readlink rootfs/etc/resolv.conf)" ]; then
	rm rootfs/etc/resolv.conf
	touch rootfs/etc/resolv.conf
fi
popd >/dev/null

# create new namespace
sudo -u $USER \
unshare --mount --propagation slave \
	--pid --net --uts --ipc --cgroup \
	--kill-child $USER_NAMESPACE \
	--fork \
	bash -c "$(cat <<-EOF
		cd "/tmp$PREFIX_DIR/$CONTAINER_NAME"
		mount -t proc proc rootfs/proc
		mount -t tmpfs tmpfs rootfs/tmp
		mount -t sysfs -o ro sysfs rootfs/sys
		# mount --rbind /sys rootfs/sys # mount if net ns is not present
		mount --rbind /dev rootfs/dev # -o ro
		mount -t tmpfs tmpfs rootfs/run
		# mount --rbind /run rootfs/run # -o ro # this or resolv.conf
		mount --bind \$(readlink -f /etc/resolv.conf) rootfs/etc/resolv.conf

		user_inode=$(readlink /proc/self/ns/user | cut -c7-16) # user ns
		if [ ! -z "$USER_NAMESPACE" ]; then
			echo "new user ns: \$user_inode"
			echo "as user: \$USER(\$(id -u \$USER))"
		fi

		echo "Enter container \"$CONTAINER_NAME\": "

		exec chroot rootfs $@
		echo "Error: program shouldn't reach here."
		EOF
	)"


cleanup
trap - EXIT # free trap

#TODO: save snapshot


echo "done!"

