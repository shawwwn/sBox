#!/bin/bash

CONTAINER_NAME=default
USER_NAMESPACE=""
PROGRAM="bash"

function help {
	echo "usage: $0: [-n|--container-name NAME] [-r|--user-root] [-h|--help] PROGRAM"
}

function cleanup {
	#echo 'cleaning up'
	if mountpoint -q "/tmp/$CONTAINER_NAME/rootfs"; then
		umount "/tmp/$CONTAINER_NAME/rootfs"
	fi
}
trap cleanup EXIT
trap "ret=$?; cleanup; exit $ret" INT QUIT TERM HUP



# transform long options to short ones
for arg in "$@"; do
	shift
	case "$arg" in
		"--container-name") set -- "$@" "-n" ;;
		"--user-root")      set -- "$@" "-r" ;;
		"--help")           set -- "$@" "-h" ;;
		*)                  set -- "$@" "$arg"
	esac
done


# process options
OPTIND=1
while getopts n:rh opt; do
	case $opt in
		n)                  CONTAINER_NAME=$OPTARG ;;
		r)                  USER_NAMESPACE="--user --map-root-user" ;;
		h)                  help
		                    exit ;;
		?)                  help
		                    exit 2 ;;
	esac
done
shift $(expr $OPTIND - 1)


# check root
if [ $(id -u) -ne 0 ]; then
	echo "need to run as root"
	exit 2
fi


# check positional arguments
if [ -z "$1" ]; then
	echo "nothing to run!" && help && exit 2
else
	PROGRAM=$(readlink -f "$1")
	[ ! -f "$PROGRAM" ] && PROGRAM=$(which "$1")
	[ -z "$PROGRAM" ] && echo "invlaid PROGRAM!" && help && exit 2
fi


# display info
echo "container name: \"$CONTAINER_NAME\"" 
[ ! -z "$USER_NAMESPACE" ] && echo "user namespace mode, root user in container will be mapped to nobody"
# TODO: Add a mode to run sanbox under a different uid.
#       First setup everything as root and setuid() to an unprivileged user_A
#       just before unshare().
#       Then map uid of user_A to root in new namespaces, so programs inside 
#       sandbox will still be run by root except this root has as much 
#       privileges as user_A.



cleanup # clean up last execution (if any)

pushd /tmp > /dev/null

# create/load rootfs
if [ ! -d "$CONTAINER_NAME" ]; then
	echo "create rootfs for \"$CONTAINER_NAME\""
	mkdir "$CONTAINER_NAME"
	cd "$CONTAINER_NAME"
	mkdir upper workdir rootfs
	cd ..
else
	echo "load previous rootfs for \"$CONTAINER_NAME\""
fi

# mount rootfs via overlayfs
mount -t overlay \
	-o lowerdir=/,upperdir="$CONTAINER_NAME/upper",workdir="$CONTAINER_NAME/workdir" \
	overlay "$CONTAINER_NAME/rootfs"

popd > /dev/null

# create new namespace
if [ -z "$USER_NAMESPACE" ]; then
	# root namespace
	user_mount="$(cat <<-EOF
		mount --rbind -o ro /dev rootfs/dev
		mount -t sysfs -o ro sysfs rootfs/sys
		EOF
	)"
else
	# user namespace
	user_mount="$(cat <<-EOF
		mount -t tmpfs tmpfs rootfs/dev
		pushd rootfs/dev >/dev/null

		touch null zero random urandom full tty
		mount --bind /dev/null null
		mount --bind /dev/zero zero
		mount --bind /dev/random random
		mount --bind /dev/urandom urandom
		mount --bind /dev/full full
		mount --bind /dev/tty tty

		ln -s /proc/self/fd fd
		ln -s /proc/self/core kcore
		ln -s /proc/self/fd/0 stdin
		ln -s /proc/self/fd/1 stdout
		ln -s /proc/self/fd/2 stderr

		mytty=\$(tty)
		mkdir shm pts ptmx
		ln -s /dev/pts/ptmx ptmx
		if [ -t 1 ] && [ -f \$mytty ]; then
			touch console
			mount --bind \$mytty console
		fi
		mount -t devpts devpts /dev/pts

		popd >/dev/null
		EOF
	)"
fi
unshare --mount --propagation slave \
	--pid \
	--kill-child $USER_NAMESPACE \
	--fork \
	bash -c "$(cat <<-EOF
		cd "/tmp/$CONTAINER_NAME"
		mount -t proc proc rootfs/proc
		mount -t tmpfs tmpfs rootfs/tmp

		$user_mount

		rm rootfs/etc/resolv.conf
		touch rootfs/etc/resolv.conf
		mount --bind /etc/resolv.conf rootfs/etc/resolv.conf

		echo "Enter container \"$CONTAINER_NAME\": "
		exec chroot /tmp/$CONTAINER_NAME/rootfs $PROGRAM
		echo "Error: program shouldn't reach here."
		EOF
	)"


cleanup
trap - EXIT # free trap
echo "done!"

