#!/bin/bash
#
# sBox
# Run programs in a sandbox environment without writting to rootfs.
#
# This program is NOT a full-fledge container like docker!
# Instead, it is a cut-down version of container, namely a sandbox, designed 
# to allow you to run programs without worrying about polluting your rootfs.
# You may chose to merge the files generated by your program into rootfs 
# once it exits.
# Will run on any platform that can run docker.
#
# Copyright: 2019 Shawwwn, shawwwn1@gmail.com
# License: MIT
#
# Usage: sbox [-n|--container-name NAME] [-r|--user-root] [-h|--help] PROGRAM
#

CONTAINER_NAME=default
USER_NAMESPACE=""
PROGRAM="bash"
USER="root"

function help {
	echo "usage: $0: [-n|--container-name NAME] [-r|--user-root USER] [-h|--help] PROGRAM"
}

function cleanup {
	#echo 'cleaning up'
	if mountpoint -q "/tmp/$CONTAINER_NAME/rootfs"; then
		umount "/tmp/$CONTAINER_NAME/rootfs"
	fi
}
trap cleanup EXIT
trap "ret=$?; cleanup; exit $ret" INT QUIT TERM HUP



# transform long options to short ones
for arg in "$@"; do
	shift
	case "$arg" in
		"--container-name") set -- "$@" "-n" ;;
		"--user-root")      set -- "$@" "-r" ;;
		"--help")           set -- "$@" "-h" ;;
		*)                  set -- "$@" "$arg"
	esac
done


# process options
OPTIND=1
while getopts n:r:h opt; do
	case $opt in
		n)                  CONTAINER_NAME=$OPTARG ;;
		r)                  USER_NAMESPACE="--user --map-root-user"
		                    USER=$OPTARG ;;
		h)                  help
		                    exit ;;
		?)                  help
		                    exit 2 ;;
	esac
done
shift $(expr $OPTIND - 1)


# check root
if [ $(id -u) -ne 0 ]; then
	echo "need to run as root"
	exit 2
fi


# check positional arguments
if [ -z "$1" ]; then
	echo "nothing to run!" && help && exit 2
fi


echo "container name: \"$CONTAINER_NAME\""
cleanup # clean up last execution (if any)
pushd /tmp > /dev/null

# create/load rootfs
if [ ! -d "$CONTAINER_NAME" ]; then
	echo "create rootfs for \"$CONTAINER_NAME\""
	mkdir "$CONTAINER_NAME"
	cd "$CONTAINER_NAME"
	mkdir upper workdir rootfs
	cd ..
else
	echo "load previous rootfs for \"$CONTAINER_NAME\""
fi

# mount rootfs via overlayfs
# TODO: another lower layer for snapshot
mount -t overlay \
	-o lowerdir=/,upperdir="$CONTAINER_NAME/upper",workdir="$CONTAINER_NAME/workdir" \
	overlay "$CONTAINER_NAME/rootfs"
popd > /dev/null


# create new namespace
# TODO: add --net
sudo -u $USER \
unshare --mount --propagation slave \
	--pid --uts --ipc --cgroup \
	--kill-child $USER_NAMESPACE \
	--fork \
	bash -c "$(cat <<-EOF
		cd "/tmp/$CONTAINER_NAME"
		mount -t proc proc rootfs/proc
		mount -t tmpfs tmpfs rootfs/tmp
		mount -t sysfs -o ro sysfs rootfs/sys
		mount --rbind /dev rootfs/dev

		mount --bind -o ro /etc/resolv.conf rootfs/etc/resolv.conf

		user_inode=$(readlink /proc/self/ns/user | cut -c7-16) # user ns
		if [ ! -z "$USER_NAMESPACE" ]; then
			echo "new user ns: \$user_inode"
			echo "as user: \$USER(\$(id -u \$USER))"
		fi

		echo "Enter container \"$CONTAINER_NAME\": "

		exec chroot rootfs $@
		echo "Error: program shouldn't reach here."
		EOF
	)"


cleanup
trap - EXIT # free trap
echo "done!"

