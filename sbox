#!/bin/bash
#
# sbox
# Run programs in a sandbox environment without writting to rootfs.
#
# This program is NOT a full-fledge container like docker!
# Instead, it is a cut-down version of container, namely a sandbox, designed 
# to allow you to run programs without worrying about polluting your rootfs.
# You may chose to merge the files generated by your program into rootfs 
# once it exits.
# Will run on any platform that can run docker.
#
# Copyright: 2019 Shawwwn, shawwwn1@gmail.com
# License: MIT
#
# Usage: sbox [OPTION] PROGRAM
#

# TODO: Only declare variables, move define operation after processing command line variables.
CONTAINER_NAME=default					# default container name
SNAPSHOT_DIR="snapshot"					# default snapshot directory name
ROOTFS_DIR='/'							# default rootfs(lower level) path
DIRTY_DIR="dirty"						# default dirty directory name
WORK_DIR="work"							# default work directory name

MAP_USER_ROOT=""
NO_NEW_PRIVS=false
USER="root"
MGT_DIR="/tmp/sbox"						# where to storage sbox management files

# default seccomp profile
# deny these syscalls once in sandbox
SYSCALL_DENYS=(
	acct
	add_key
	bpf
	clock_adjtime
	clock_settime
	create_module
	delete_module
	finit_module
	get_kernel_syms
	get_mempolicy
	init_module
	ioperm
	iopl
	kcmp
	kexec_file_load
	kexec_load
	keyctl
	lookup_dcookie
	mbind
	move_pages
	name_to_handle_at
	nfsservctl
	perf_event_open
	pivot_root
	process_vm_readv
	process_vm_writev
	ptrace
	query_module
	quotactl
	reboot
	request_key
	set_mempolicy
	settimeofday
	stime
	swapon
	swapoff
	sysfs
	_sysctl
	uselib
	userfaultfd
	ustat
	vm86
	vm86old
)

CAP_DROPS="\
CAP_DAC_READ_SEARCH,\
CAP_IPC_LOCK,\
CAP_IPC_OWNER,\
CAP_LEASE,\
CAP_LINUX_IMMUTABLE,\
CAP_MAC_ADMIN,\
CAP_MAC_OVERRIDE,\
CAP_NET_BROADCAST,\
CAP_AUDIT_CONTROL,\
CAP_AUDIT_READ,\
CAP_BLOCK_SUSPEND,\
CAP_SYS_BOOT,\
CAP_SYS_MODULE,\
CAP_SYS_NICE,\
CAP_SYS_PACCT,\
CAP_SYS_PTRACE,\
CAP_SYS_RAWIO,\
CAP_SYS_RESOURCE,\
CAP_SYS_TIME,\
CAP_SYS_TTY_CONFIG,\
CAP_SYSLOG,\
CAP_WAKE_ALARM\
"

usage() {
	echo "usage: $0: [OPTION] PROGRAM"
	echo "Run with '--help' for more information."
}

help() {
	echo "usage: $0: [OPTION] PROGRAM"
	echo "Run <PROGRAM> in a sandbox environment without writting to rootfs."
	echo ""
	echo "	-n, --container-name NAME"
	echo "		Name/Identifier of the underlying sandbox."
	echo "		Sandbox work directory will be created at /tmp/sbox/<NAME>."
	echo "		Default sandbox name is 'default'."
	echo ""
	echo "	-u, --user-root USER"
	echo "		Create user namespace as unprivileged user <USER>,"
	echo "		root's privileges inside sandbox will be bound by the user."
	echo ""
	echo "	-d, --snapshot-dir DIR"
	echo "		Directory to store files generated by sandboxed program."
	echo "		Default location is /tmp/sbox/<NAME>/snapshot."
	echo ""
	echo "	-t, --dirty-dir DIR"
	echo "		Directory to cache temporary changes to filesystem."
	echo "		Default location is /tmp/sbox/<NAME>/dirty."
	echo ""
	echo "	-w, --work-dir DIR"
	echo "		Directory to store overlayfs's internal files."
	echo "		Must be under the same mount with dirty_dir for OverlayFS to "
	echo "		work."
	echo "		Default location is /tmp/sbox/<NAME>/work."
	echo ""
	echo "	-B, --seccomp-blacklist SYSCALLS"
	echo "		Deny syscalls that are in list SYSCALLS inside sandbox."
	echo "		List SYSCALLS has a format of 'syscall1,syscall2,syscall3' "
	echo "		(no space in between function names)."
	echo ""
	echo "	-D, --cap-drop CAPS"
	echo "		Drop capabilities that are in list CAPS inside sandbox."
	echo "		List CAPS has a format of 'cap1,cap2,cap3' "
	echo "		(no space in between cap names)."
	echo ""
	echo "	-N, --no-new-privs"
	echo "		Prevent sandboxed program from gaining new privileges."
	echo "		https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt"
	echo ""
	echo "	-A --apparmor-profile PROFILE"
	echo "		Apply AppArmor profile to sandboxed PROGRAM."
	echo "		Kernel must support apparmor."
	echo "		May need to install extra dependencies."
	echo ""
	echo "	-g, --cgroup CONTROLLERS:PATH"
	echo "		Add sandbox's main process to control group(s)."
	echo ""
	echo "	-c, --auto-commit"
	echo "		Auto commit file system changes to snapshot when exit."
	echo ""
	echo "	-v, --verbose"
	echo "		Print more information."
	echo ""
	echo "	-h, --help"
	echo "		Display this help and exit."
}

#############################################################
# Clean up operations during exit
#############################################################
mount_teardown() {
	# umount overlayfs
	if mountpoint -q "$MGT_DIR/$CONTAINER_NAME/rootfs"; then
		umount "$MGT_DIR/$CONTAINER_NAME/rootfs"
	fi

	rm "$PIPE1" >/dev/null 2>&1
	rm "$PIPE2" >/dev/null 2>&1
}
trap mount_teardown EXIT
trap "ret=$?; mount_teardown; exit $ret" INT QUIT TERM HUP
set -m # job control


# transform long options to short ones
for arg in "$@"; do
	shift
	case "$arg" in
		"--container-name")       set -- "$@" "-n" ;;
		"--user-root")            set -- "$@" "-u" ;;
		"--snapshot-dir")         set -- "$@" "-d" ;;
		"--dirty-dir")            set -- "$@" "-t" ;;
		"--work-dir")             set -- "$@" "-w" ;;
		"--auto-commit")          set -- "$@" "-c" ;;
		"--cgroup")               set -- "$@" "-g" ;;
		"--no-new-privs")         set -- "$@" "-N" ;;
		"--seccomp-blacklist")    set -- "$@" "-B" ;;
		"--cap-drop")             set -- "$@" "-D" ;;
		"--apparmor-profile")     set -- "$@" "-A" ;;
		"--verbose")              set -- "$@" "-v" ;;
		"--help")                 set -- "$@" "-h" ;;
		*)                        set -- "$@" "$arg"
	esac
done

#############################################################
# Evalution command line arg's value into simple true or false
#############################################################
true_or_false() {
	local opt="$1"
	shopt -s nocasematch

	# remove starting '=' if found
	local first_char=$(cut -c 1 <<<"$opt")
	if [ "$first_char" = "=" ]; then
		opt=$(cut -c 2- <<<"$opt")
	fi

	if [[ "$opt" == "y" ]] \
	|| [[ "$opt" == "yes" ]] \
	|| [[ "$opt" == "true" ]] \
	|| [[ "$opt" == "t" ]]; then
		echo "true"
	elif [[ "$opt" == "n" ]] \
	|| [[ "$opt" == "no" ]] \
	|| [[ "$opt" == "f" ]] \
	|| [[ "$opt" == "false" ]]; then
		echo "false"
	fi

	shopt -u nocasematch
}

# process options
VERBOSE=false
OPTIND=1
AA_PROFILE=
AA_PROFILE_NAMES=
CGROUPS=

while getopts n:u:d:t:w:c:g:NB:D:A:vh opt; do
	case $opt in
		n)                  CONTAINER_NAME=$OPTARG ;;
		u)                  MAP_USER_ROOT="--map-root-user"
		                    USER=$OPTARG ;;
		d)                  SNAPSHOT_DIR=$OPTARG ;;
		t)                  DIRTY_DIR=$OPTARG ;;
		w)                  WORK_DIR=$OPTARG ;;
		c)                  AUTO_COMMIT="$(true_or_false $OPTARG)" # env var
		                    if [ -z "$AUTO_COMMIT" ]; then
		                        echo "Unrecognized Value: $OPTARG" >&2
		                        exit 2
		                    fi ;;
		g)                  CGROUPS="$CGROUPS$OPTARG|" ;;
		N)                  NO_NEW_PRIVS=true ;;
		B)                  IFS=',' read -a SYSCALL_DENYS <<< "$OPTARG"
		                    echo "deny syscalls: $OPTARG" ;;
		D)                  CAP_DROPS="$(echo $OPTARG | awk '{print tolower($0)}')"
		                    echo "drop capabilities: $CAP_DROPS" ;;
		A)                  AA_PROFILE="$OPTARG" ;;
		v)                  echo "verbose on"
		                    VERBOSE=true ;;
		h)                  help
		                    exit ;;
		?)                  usage
		                    exit 2 ;;
	esac
done
shift $(expr $OPTIND - 1)

# check root
if [ $(id -u) -ne 0 ]; then
	echo "need to be run as root" >&2
	exit 2
fi

# check positional arguments
if [ -z "$1" ]; then
	echo "nothing to run!" >&2
	usage
	exit 2
fi

# TODO: Read config under $CONTAINER_NAME, assign unset variables with values in config.
#       If container not created, assign unset variables to default.

# check if cgroup is not enabled
if [ ! -z "$CGROUPS" ] && [ -z "$(grep '\<cgroup\>' /proc/filesystems)" ]; then
	echo "cgroup is not enabled!" >&2
	exit 1
fi




#############################################################
# Globals:
#     AA_PROFILE
#     AA_PROFILE_NAMES
#############################################################
apparmor_setup() {
	if [ ! -z "$AA_PROFILE" ]; then
		if ! ls -d /sys/module/apparmor/ >/dev/null 2>&1; then
			echo -e "Error: AppArmor module not found!\nNeed to install 'apparmor' package first." >&2
			exit 1
		elif ! which aa-enabled >/dev/null; then
			echo "Error: Need to install 'apparmor-utils' package first." >&2
		elif ! aa-enabled --quiet >/dev/null; then
			echo "Error: AppArmor not enabled!" >&2
			exit 1
		fi

		local profs_old=($(aa-status --pretty-json | jq -r '.profiles | to_entries[] | .key')) # profiles loaded in kernel
		local profs_new=$(apparmor_parser -N "$AA_PROFILE")
		echo "apparmor profile: (${AA_PROFILE[@]})"
		if [ -z $profs_old ]; then
			AA_PROFILE_NAMES=($profs_new)
		else
			AA_PROFILE_NAMES=($(echo "$profs_new" | grep -v ${profs_old[@]/#/-e })) # excludes olds from news
		fi
		apparmor_parser -a "$AA_PROFILE" >/dev/null 2>&1 # load profile file
		AA_PROFILE=($profs_new) # store profile name(s) instead of profile file
		$VERBOSE && echo "apparmor profile loaded: (${AA_PROFILE[@]})"
	fi
}
apparmor_teardown() {
	enable -f sbox-aa.so aa_remove_profile
	$VERBOSE && echo "reset apparmor"
	local prof
	if [ ! -z "${AA_PROFILE_NAMES[@]}" ]; then
		$VERBOSE && echo "unload apparmor profile: ${AA_PROFILE_NAMES[@]}"
		aa_remove_profile ${AA_PROFILE_NAMES[@]}
	fi
	unset AA_PROFILE_NAMES
}

#############################################################
# The layer right above rootfs, contains initial settings.
# Do not put empty directory(s) in here unless you know what 
# you are doing as it will cause upper layer to create opaque 
# directory so to furthur complicate merging.
# [LOW] rootfs -> firmware -> snapshot -> dirty [HIGH]
#############################################################
debootstrap_firmware_layer() {
	local firmware_dir="$1"
	mkdir -p "$firmware_dir" >/dev/null 2>&1

	pushd "$firmware_dir" >/dev/null
	mkdir -p "etc"
	echo "nameserver 8.8.8.8" >etc/resolv.conf

	mkdir -p "var"
	ln -s "/run" "var/run"
	popd >/dev/null
}


#############################################################
# Create and mount sandbox's rootfs
# Create all necessary files for sandbox
#############################################################
debootstrap_sandbox() {
	local name="$CONTAINER_NAME"

	mkdir "$MGT_DIR" >/dev/null 2>&1
	pushd "$MGT_DIR" >/dev/null

	mkdir -p "$name" >/dev/null 2>&1
	pushd "$name" >/dev/null
	SNAPSHOT_DIR=$(realpath -m "$SNAPSHOT_DIR") # resolve to abs path
	DIRTY_DIR=$(realpath -m "$DIRTY_DIR") # resolve to abs path
	WORK_DIR=$(realpath -m "$WORK_DIR") # resolve to abs path
	popd >/dev/null

	# create/load rootfs
	mkdir -p "$DIRTY_DIR" >/dev/null 2>&1
	mkdir -p "$WORK_DIR" >/dev/null 2>&1
	local m1=$(df -P "$DIRTY_DIR" | tail -1 | cut -d' ' -f 1)
	local m2=$(df -P "$WORK_DIR" | tail -1 | cut -d' ' -f 1)
	if [ "$m1" != "$m2" ]; then
		echo "Dirty directory and Work directory must reside under the same mount." >&2
		exit 1
	fi

	mkdir -p "$name/rootfs" >/dev/null 2>&1
	firmware_dir=$(realpath "$name/firmware") # to abs path
	debootstrap_firmware_layer "$firmware_dir" >/dev/null 2>&1
	cd "$name" # /tmp/sbox/$CONTAINER_NAME
	mkdir -p "$SNAPSHOT_DIR" >/dev/null 2>&1 # create snapshot directory

	if [ ! -z "$(ls -A $SNAPSHOT_DIR)" ]; then
		echo "load previous snapshot from $SNAPSHOT_DIR"
	fi

	# mount rootfs via overlayfs
	# LOW <----------------------------------> HIGH
	# [/] -> [firmware] -> [snapshot_dir] -> [dirty] <= file i/o
	mount -t overlay \
		-o lowerdir="$SNAPSHOT_DIR":"$firmware_dir":/,upperdir="$DIRTY_DIR",workdir="$WORK_DIR" \
		overlay "rootfs"
	if [ $? -ne 0 ]; then
		echo "Unable to mount overlayfs!" >&2
		exit 1
	fi

	popd >/dev/null
}


#############################################################
# Like xargs but works with bash function
#############################################################
xxargs() {
	local flag_t=false
	[ "$1" == "-t" ] && { flag_t=true; shift; }
	local prog="$1"
	shift
	local args=()
	for arg in "$@"; do
		args=("${args[@]}" "\"$arg\"")
	done

	local line
	local ret=true
	while read line; do
		$flag_t && echo "$prog ${args[@]} $line"
		eval "$prog ${args[@]} $line"
		ret=$((ret | $?))
	done
	return $ret
}


#############################################################
# Converting a text syscall function name to 
# architecture-based syscall reference number.
#############################################################
syscall2num() {
	local fn="$1"

	local num
	local re="#define __NR_$fn\s+(\d+)"
	case "$(uname -m)" in
		x86-64)
			num=$(cat /usr/include/asm/unistd_64.h | pcregrep -i -o1 -e "$re") ;;
		i386)
			num=$(cat /usr/include/asm/unistd_32.h | pcregrep -i -o1 -e "$re") ;;
		x32)
			num=$(cat /usr/include/asm/unistd_x32.h | pcregrep -i -o1 -e "#define __NR_$fn \(__X32_SYSCALL_BIT \+ (\d+)") ;;
		arm*|aarch*)
			num=$(cat /usr/include/asm-generic/unistd.h | pcregrep -i -o1 -e "$re") ;;
		*)
			echo "Unknown platform!" >&2 ;;
	esac

	# use method 2
	[ -z "$num" ] && num=$(printf "#include <sys/syscall.h>\nSYS_$fn" | gcc -E -P - | tail -n1)
	
	if  [ -n "$num" ] && [ "$num" -eq "$num" ] 2>/dev/null; then
		echo $num
	fi
}
syscall2nums() {
	local syscalls=("$@")
	local syscall_nos=()
	local fn
	for fn in "${syscalls[@]}"; do
		syscall_nos+=($(syscall2num $fn))
	done
	echo ${syscall_nos[@]}
}


#############################################################
# convert an ip address to decimal number.
#############################################################
ip2num() {
	local a b c d
	IFS=. read -r a b c d <<< "$1"
	echo "$(((a << 24) + (b << 16) + (c << 8) + d))"
}


#############################################################
# convert a decimal number to ip address.
#############################################################
num2ip () {
	local a b c d
	a=$(((0xFF000000 & $1) >> 24))
	b=$(((0x00FF0000 & $1) >> 16))
	c=$(((0x0000FF00 & $1) >> 8))
	d=$(((0x000000FF & $1) >> 0))
	echo "$a.$b.$c.$d"
}


#############################################################
# Input a masked ip representing a subnet.
# Output the first and last ips in that subnet.
#############################################################
get_subnet_range() {
	local numeric_output=false
	[ "$1" == "-n" ] && { numeric_output=true; shift; }
	local masked_ip="$1" # eg 10.8.3.1/24

	local arr category addr
	local start end
	mapfile -t arr < <(ipcalc -nb $masked_ip)
	for l in "${arr[@]}"; do
		IFS=' ' read category addr <<< "$l"
		if [[ $category == "Network"* ]]; then
			start=$(echo $addr | sed 's/\/[0-9]\+//')
		elif [[ $category == "Broadcast"* ]]; then
			end=$addr
		elif [[ $category == "Hostroute"* ]]; then
			start=$addr
			end=$addr
		fi
	done

	if $numeric_output; then
		echo "$(ip2num $start) $(ip2num $end)"
	else
		echo "$start $end"
	fi
}


#############################################################
# Get all subnets from system in ip form.
# Output a pair of first and last addresses.
# of spans.
# Arguments:
#     -n       output a pair of numbers instead of ip addr
#############################################################
get_sys_subnets() {
	local flag_n
	[ "$1" == "-n" ] && { flag_n="-n"; shift; }

	ip addr show | pcregrep -io -e '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(\/[0-9]+)?' | \
	while read -r line; do
		[[ $line != */* ]] && line="$line/32"
		local start=""
		local end=""
		local args=($flag_n $line)
		read start end <<< $(get_subnet_range "${args[@]}")
		echo "$start $end"
	done
}




#############################################################
# Perform union operation of the given span against a set of 
# spans.
# Print the union span.
# e.g.,
# union ([2,7], {[1,3], [5,9], [10,15]}) ==> {[1,9], [10,15]}
# Globals:
#     starts
#     ends
#############################################################
starts=() # global span set
ends=() # global span set
spans_union() {
	local s=$1
	local e=$2
	local start end
	local i j
	local len=${#starts[@]}

	start=$s
	for ((i=0; i<len; i++)); do
		if ((s < ${starts[i]})); then
			start=$s
			break
		elif ((s >= ${starts[i]})) && ((s <= ${ends[i]})); then
			start=${starts[$i]}
			break
		fi
	done

	end=$e
	for ((j=0; j<len; j++)); do
		if ((e < ${starts[$j]})); then
			end=$e
			break
		elif ((e >= ${starts[$j]})) && ((e <= ${ends[$j]})); then
			end=${ends[$j]}
			((j++))
			break
		fi
	done

	starts=("${starts[@]:0:$i}" "$start" "${starts[@]:$j}")
	ends=("${ends[@]:0:$i}" "$end" "${ends[@]:$j}")
	echo "$start $end"
}


#############################################################
# Check if a give span intersects with a set of spans.
# Print the end of intersection boundary.
# e.g.,
# intersect ([2,7], {[0,1], [10,15]}) ==> false
# intersect ([2,7], {[0,3], [5,15]}) ==> true
# Globals:
#     starts
#     ends
#############################################################
spans_intersected() {
	local s=$1
	local e=$2
	local len=${#starts[@]}

	for ((i=0; i<len; i++)); do
		if ( ((s >= ${starts[i]})) && ((s <= ${ends[i]})) ) || \
			( ((e >= ${starts[i]})) && ((e <= ${ends[i]})) ) || \
			( ((s < ${starts[i]})) && ((e > ${ends[i]})) ); then
			echo $((e>${ends[i]} ? e : ${ends[i]})) # max
			return 0
		fi
	done
	return 1
}


#############################################################
# Get system subnet range as a pair of numbers.
# Save these range pairs to a global variable by doing the 
# same union operation against that global variable over and
# over.
# Globals:
#     starts
#     ends
#############################################################
save_sys_subnets_as_spans() {
	local l h
	while read -r l h; do
		# echo "set $l $h"
		spans_union $l $h >/dev/null 2>&1
	done < <(get_sys_subnets -n)
}


#############################################################
# Given a starting address and a subnet mask, return the 
# ip address to the next available subnet.
# Subnet starts from subnet lower bound determined by the 
# subnet mask.
#############################################################
get_avail_subnet_from_sys() {
	local start_ip="$1"
	local subnet_mask="$2"

	local ip_dec=$(ip2num "$start_ip")
	local ip=$start_ip
	while [ $ip_dec -lt 4294967295 ]; do # 0xFFFFFFFF
		ip_next=$(get_subnet_range -n "$ip/$subnet_mask" | xxargs spans_intersected)
		if [ ! -z "$ip_next" ]; then
			ip_dec=$((ip_next + 1))
			ip=$(num2ip $ip_dec)
		else
			ip=$(get_subnet_range "$ip/$subnet_mask" | awk '{print $1}')
			break
		fi
	done
	
	echo "$ip"
}

#############################################################
# Given a starting address and size of the range(number of 
# addresses), return the start ip address of the available 
# range.
#############################################################
get_avail_ips_from_sys () {
	local start_ip="$1" # start of the ip range
	local n="$2" # size of the ip range

	local ip_start_dec=$(ip2num "$start_ip")
	local ip_end_dec
	while [ $ip_start_dec -lt 4294967295 ]; do # 0xFFFFFFFF
		ip_end_dec=$((ip_start_dec + n - 1))
		ip_boundary_dec=$(spans_intersected $ip_start_dec $ip_end_dec)
		if [ $? -eq 0 ]; then
			# intersected, search again
			ip_start_dec=$((ip_boundary_dec + 1))
		else
			# not intersected, output
			echo $(num2ip "$ip_start_dec")
			break
		fi
	done
}

#############################################################
# Apply cgroup(s) to pid.
#############################################################
cgroup_apply() {
	local pid=$1
	local cgs=$2

	local cmd
	IFS='|' read -ra cmd <<< "$cgs"
	cmd="$(echo ${cmd[@]/#/-g })" # "-g cpuset:bb -g memory:cc"
	cgclassify --sticky $cmd $pid
	return $?
}

#############################################################
# Read in system network settings, get a pair of available
# ip's set to global variables for further process.
# Globals:
#     IP_A         pair ip for host
#     IP_B         pair ip for sandbox
#############################################################
IP_A="192.168.50.1" # default
IP_B="192.168.50.2" # default
eth_init() {
	save_sys_subnets_as_spans # load current network setup

	IP_A="$(get_avail_ips_from_sys "$IP_A" 2)"
	IP_B="$(num2ip $(($(ip2num $IP_A) + 1)))"
	$VERBOSE && echo "ppp: $IP_A <--> $IP_B"
	echo "Assigning ip $IP_B for sandbox"
}

#############################################################
# Setup network for sandbox.
# Using pair-interface and point-to-point connection
# Must run after invoking eth_init()
# Globals:
#     IP_A         pair ip for host
#     IP_B         pair ip for sandbox
#############################################################
eth_setup() {
	local p1=$1 # pipe1
	local p2=$2 # pipe2
	fail() {
		local _
		read -t 0.1 _ <$p1
		echo "Error: $1" >$p2
		exit 1
	}

	# wait for sandbox pid
	local pid
	read pid <$p1
	rm $p1 # rm $PIPE1
	if [ ! -n "$pid" ] || [ ! "$pid" -eq "$pid" ] 2>/dev/null; then
		fail "Unable to get unshare pid when setting up network!"
	fi
	$VERBOSE && echo "sandbox pid: $pid"
	echo $pid > "$MGT_DIR/$CONTAINER_NAME/container.pid" # write pid file
	echo "SBOX_PID=\"$pid\"" >> "$MGT_DIR/$CONTAINER_NAME/config"

	# apply cgroup to sandbox
	[ ! -z "$CGROUPS" ] && cgroup_apply "$pid" "$CGROUPS"

	# setup network on host
	$VERBOSE && echo "setup pair interfaces: [host]veth_$CONTAINER_NAME <--> [sandbox]veth0"
	ip link add "veth_$CONTAINER_NAME" type veth peer name "veth0" netns "$pid" # veth0 for sandbox
	[ $? -ne 0 ] && fail "Unable to create network interfaces!"
	ip addr add "$IP_A" peer "$IP_B" dev "veth_$CONTAINER_NAME" # ppp: IP_A -> IP_B
	ip link set "veth_$CONTAINER_NAME" up

	local default_nic=$(route | grep '^default' | grep -o '[^ ]*$' | head -n1)
	local default_subnet=$(ip addr show dev $default_nic | pcregrep -io -e '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\/[0-9]+')
	#iptables -P FORWARD DROP
	iptables -t nat -A POSTROUTING -s "$IP_B" -o "$default_nic" -j MASQUERADE # {IP_A, IP_B}
	iptables -A INPUT -i "veth_$CONTAINER_NAME" -d "$default_subnet" -j DROP # prevent access to host subnet
	iptables -A FORWARD -i "veth_$CONTAINER_NAME" -d "$default_subnet" -j DROP # prevent access to host subnet
	iptables -A FORWARD -i "$default_nic" -o "veth_$CONTAINER_NAME" -j ACCEPT
	iptables -A FORWARD -o "$default_nic" -i "veth_$CONTAINER_NAME" -j ACCEPT

	# setup network on sandbox
	mkdir -p "/var/run/netns" >/dev/null 2>&1
	touch "/var/run/netns/ns_$CONTAINER_NAME"
	mount --bind "/proc/$pid/ns/net" "/var/run/netns/ns_$CONTAINER_NAME"
	ip netns exec "ns_$CONTAINER_NAME" ip addr add "$IP_B" peer "$IP_A" dev "veth0" # ppp: IP_B -> IP_A
	ip netns exec "ns_$CONTAINER_NAME" ip link set "veth0" up
	ip netns exec "ns_$CONTAINER_NAME" ip link set lo up
	ip netns exec "ns_$CONTAINER_NAME" ip route add default via "$IP_A" # route all traffic to go in veth0, out veth_$CONTAINER_NAME
	umount "/var/run/netns/ns_$CONTAINER_NAME"
	rm "/var/run/netns/ns_$CONTAINER_NAME"
	echo "eth_setup() exit" >$p2 # signal main process that we are done
}

#############################################################
# Remove network setup for sandbox.
# Globals:
#     IP_A         pair ip for host
#     IP_B         pair ip for sandbox
#############################################################
eth_teardown() {
	$VERBOSE && echo "teardown network"
	local default_nic=$(route | grep '^default' | grep -o '[^ ]*$' | head -n1)
	local default_subnet=$(ip addr show dev $default_nic | pcregrep -io -e '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\/[0-9]+')
	iptables -t nat -D POSTROUTING -s "$IP_B" -o "$default_nic" -j MASQUERADE >/dev/null 2>&1
	iptables -D INPUT -i "veth_$CONTAINER_NAME" -d "$default_subnet" -j DROP >/dev/null 2>&1
	iptables -D FORWARD -i "veth_$CONTAINER_NAME" -d "$default_subnet" -j DROP >/dev/null 2>&1
	iptables -D FORWARD -i "$default_nic" -o "veth_$CONTAINER_NAME" -j ACCEPT >/dev/null 2>&1
	iptables -D FORWARD -o "$default_nic" -i "veth_$CONTAINER_NAME" -j ACCEPT >/dev/null 2>&1
	ip link delete "veth_$CONTAINER_NAME" >/dev/null 2>&1
}

#############################################################
# Return container pid if running
#############################################################
get_container_pid() {
	local name="$1"
	local pid=$(cat "$MGT_DIR/$name/container.pid" 2>/dev/null)
	if [ ! -z "$pid" ] && (ps -p "$pid" >/dev/null 2>&1); then
		echo "$pid"
		return 0
	fi
	return 1;
}

#############################################################
# Generate kernel-supported namespace flags for unshare.
# In case kernel doesn't support one or more namespaces 
# requested by unshare.
# Globals:
#     MAP_USER_ROOT
#############################################################
gen_supported_ns_flags() {
	local namespaces=($(ls /proc/self/ns))
	local ns
	local flags=""
	for ns in "${namespaces[@]}"; do
		case "$ns" in
			cgroup)
				flags="$flags --cgroup" ;;
			ipc)
				flags="$flags --ipc" ;;
			mnt)
				flags="$flags --mount --propagation slave" ;;
			net)
				flags="$flags --net" ;;
			pid)
				flags="$flags --pid" ;;
			uts)
				flags="$flags --uts" ;;
			user)
				[ ! -z "$MAP_USER_ROOT" ] && flags="$flags --user" ;;
			*)
				echo "Error: unsupported namespace $ns?" >&2
				exit 1 ;;
		esac
	done
	echo "$flags"
}

#############################################################
# Save current sandbox's settings to file.
# Globals:
#     MAP_USER_ROOT
#############################################################
save_config() {
	local config_file="$1"
	local pid=$$
	shift
	{
		echo "SBOX_NAME=\"$CONTAINER_NAME\""
		echo "SBOX_LOC=\"$MGT_DIR/$CONTAINER_NAME\""
		echo "SBOX_SNAPSHOT_DIR=\"$SNAPSHOT_DIR\""
		echo "SBOX_DIRTY_DIR=\"$DIRTY_DIR\""
		echo "SBOX_WORK_DIR=\"$WORK_DIR\""
		echo "SBOX_ROOTFS_DIR='$ROOTFS_DIR'"
		echo "SBOX_CAP_DROPS=\"$CAP_DROPS\""
		echo "SBOX_SYSCALL_DENYS=\"${SYSCALL_DENYS[@]}\""
		echo "SBOX_CGROUPS=\"$CGROUPS\""
		echo "SBOX_AA_PROFILE=\"$AA_PROFILE\""
		echo "SBOX_AA_PROFILE_NAMES=\"$AA_PROFILE_NAMES\""
		echo "SBOX_NO_NEW_PRIVS=\"$NO_NEW_PRIVS\""
		echo "SBOX_USER=\"$USER\""
		echo "SBOX_AUTO_COMMIT=\"$AUTO_COMMIT\""
		echo "SBOX_EXEC=\"$@\""
		echo "SBOX_PPID=\"$pid\"" # parent of the sandbox'ed process
	} | tee "$config_file" | {
		if $VERBOSE; then
			echo "sbox config:"
			cat
		else
			cat >/dev/null; # if pipeline doesn't have an endpoint, previous tee won't work
		fi
	}
}



KILLED=false
PID=$(get_container_pid "$CONTAINER_NAME")
if [ ! -z "$PID" ]; then
	trap - EXIT INT QUIT TERM HUP # free traps
	$VERBOSE && echo "running container pid: $PID"

	echo -e "Container \"$CONTAINER_NAME\" is already running.\n\nUse \"sbox-mgt join\" to send process into a running container." >&2
	exit 2
fi

apparmor_setup
debootstrap_sandbox "$CONTAINER_NAME" # create work files
PIPE1=$(mktemp -u) # for receiving namespace pid in task
PIPE2=$(mktemp -u) # for receiving task finish signal
sudo -u $USER mkfifo $PIPE1 $PIPE2
$VERBOSE && echo "eth_setup() start"
eth_init
eth_setup $PIPE1 $PIPE2 & # async

# save current sandbox's settings
save_config "$MGT_DIR/$CONTAINER_NAME/config" $@

# syscall name to kernel reference number
SYSCALL_DENYS=($(syscall2nums "${SYSCALL_DENYS[@]}"))

# create new namespace (cont'd --cgroup)
NS_FLAGS="$(gen_supported_ns_flags)"
sudo -u $USER \
unshare --kill-child --fork \
	$NS_FLAGS \
	$MAP_USER_ROOT \
	bash -c """$(cat <<-EOF
		# send current shell pid to background task
		cat /proc/self/status | grep ^PPid: | awk '{print \$2}' >$PIPE1

		read str <$PIPE2
		if [[ "\$str" == "Error:"* ]]; then
			echo -e "\\e[31m\$str\\e[0m" >&2
			exit 1
		else
			$VERBOSE && echo "\$str"
		fi
		rm $PIPE2

		# mountings
		cd "$MGT_DIR/$CONTAINER_NAME"
		mount -t proc proc rootfs/proc
		mount -t tmpfs tmpfs rootfs/tmp
		mount -t sysfs -r sysfs rootfs/sys
		# mount --rbind -r /sys rootfs/sys # mount if net ns is not present
		mount --rbind /dev rootfs/dev # -r ?
		mount -t tmpfs tmpfs rootfs/run
		# mount --rbind -r /run rootfs/run # this or resolv.conf
		mount --bind \$(readlink -f /etc/resolv.conf) rootfs/etc/resolv.conf

		# display extra info if enters user namespace
		if [ ! -z "$MAP_USER_ROOT" ]; then
			user_inode=$(readlink /proc/self/ns/user | cut -c7-16) # user ns
			echo "enter new user namespace \"\$user_inode\""
			echo "as user \"\$USER\" (\$(id -u \$USER))"
		fi

		echo "Entering container \"$CONTAINER_NAME\": "
		$VERBOSE && echo "dropping capabilities ($(echo $CAP_DROPS | sed "s/,/ /g"))"

		exec chroot rootfs \
			capsh --drop="$CAP_DROPS" -- -c '
				cd ~
				
				enable -f sbox-seccomp.so seccomp
				$VERBOSE && echo "blacklisting syscalls (${SYSCALL_DENYS[@]})"
				$NO_NEW_PRIVS && seccomp --no-new-privs
				seccomp -a blacklist ${SYSCALL_DENYS[@]}

				$VERBOSE && echo "applying apparmor profiles (${AA_PROFILE[@]})"
				enable -f sbox-aa.so aa_change_profile
				profs=(${AA_PROFILE[@]})
				for prof in "\${profs[@]}"; do
					aa_change_profile "\$prof"
					[ \$? -eq 0 ] && $VERBOSE && echo "profile applied: \$prof"
				done

				exec $@
			'
		echo "Error: program shouldn't reach here." >&2
		EOF
	)"""
[ $? == 137 ] && KILLED=true

apparmor_teardown
eth_teardown
mount_teardown
trap - EXIT INT QUIT TERM HUP # free traps
$KILLED && stty sane # to fix shell's strange behavior when child process was killed(-9) then returned to shell
# $KILLED && kill -9 $$

#Save snapshot
pushd "$MGT_DIR/$CONTAINER_NAME" >/dev/null

tree -Ca "$DIRTY_DIR"
size=$(du -sPh "$DIRTY_DIR" | cut -f1-1)
verbose_cmd=$($VERBOSE && echo '--verbose')
echo "$size data generated."

# environment variable: AUTO_COMMIT
if [ -z "$AUTO_COMMIT" ]; then
	while true; do
		read -p "> Commit changes to snapshot? [Y/n] " -e yn
		case $yn in
			"" | [Yy]* )
				sbox-fstool commit "$CONTAINER_NAME" "$verbose_cmd" \
					--dirty-dir "$DIRTY_DIR" \
					--snapshot-dir "$SNAPSHOT_DIR" && \
				echo "committed to $SNAPSHOT_DIR"
				break
				;;
			[Nn]* )
				echo "Abort."
				$VERBOSE && echo "remove $DIRTY_DIR"
				rm -r "$DIRTY_DIR" >/dev/null 2>&1
				exit 0
				;;
			* ) ;;
		esac
	done
elif $AUTO_COMMIT; then
	echo "auto commit"
	sbox-fstool commit "$CONTAINER_NAME" "$verbose_cmd" \
		--dirty-dir "$DIRTY_DIR" \
		--snapshot-dir "$SNAPSHOT_DIR" && \
	echo "committed to $SNAPSHOT_DIR"
	[ -z "$AUTO_MERGE" ] && exit 0 # when -c flag set via sbox not sbox-mgt
else
	echo "discard changes"
	$VERBOSE && echo "remove $DIRTY_DIR"
	rm -r "$DIRTY_DIR" >/dev/null 2>&1
	[ -z "$AUTO_MERGE" ] && exit 0 # when -c flag set via sbox not sbox-mgt
fi

size=$(du -sPh "$SNAPSHOT_DIR" | cut -f1-1)
file_count=$(find "$SNAPSHOT_DIR" -type f | wc -l)
dir_count=$(find "$SNAPSHOT_DIR" -mindepth 1 -type d | wc -l)
echo "Snapshot size $size ($file_count files, $dir_count directories)."

# environment variable: AUTO_MERGE
if [ -z "$AUTO_MERGE" ]; then
	while true; do
		read -p "> Merge snapshot with local filesystem? [N/y] " -e yn
		case $yn in
			[Yy]* ) 
				sbox-fstool merge "$CONTAINER_NAME" "$verbose_cmd" \
					--snapshot-dir "$SNAPSHOT_DIR" \
					--rootfs-dir '$ROOTFS_DIR' && \
				echo "snapshot merged"
				break
				;;
			"" | [Nn]* ) 
				echo "Abort."
				exit
				;;
			* ) ;;
		esac
	done
elif $AUTO_MERGE; then
	echo "auto merge"
	sbox-fstool merge "$CONTAINER_NAME" "$verbose_cmd" \
		--snapshot-dir "$SNAPSHOT_DIR" \
		--rootfs-dir '$ROOTFS_DIR' && \
	echo "snapshot merged"
else
	echo "Abort."
fi

popd >/dev/null
