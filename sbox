#!/bin/bash
#
# sbox
# Run programs in a sandbox environment without writting to rootfs.
#
# This program is NOT a full-fledge container like docker!
# Instead, it is a cut-down version of container, namely a sandbox, designed 
# to allow you to run programs without worrying about polluting your rootfs.
# You may chose to merge the files generated by your program into rootfs 
# once it exits.
# Will run on any platform that can run docker.
#
# Copyright: 2019 Shawwwn, shawwwn1@gmail.com
# License: MIT
#
# Usage: sbox [OPTION] PROGRAM
#
CONTAINER_NAME=default					# default container name
SNAPSHOT_DIR="snapshot"					# default snapshot directory name

USER_NAMESPACE_CMD=""
USER="root"
PREFIX_DIR="/sbox"

function help {
	echo "usage: $0: [OPTION] PROGRAM"
	echo "Run <PROGRAM> in a sandbox environment without writting to rootfs."
	echo ""
	echo "	-n, --container-name NAME"
	echo "		Mount OverlayFS at /tmp/sbox/<NAME>."
	echo "		Default cantainer name is 'default'."
	echo ""
	echo "	-u, --user-root USER"
	echo "		Create user namespace as unprivileged user <USER>,"
	echo "		so that its privileges will be bound by the user."
	echo ""
	echo "	-d, --snapshot-dir DIR"
	echo "		Directory to store files generated by sandboxed program."
	echo "		Default location is /tmp/sbox/<NAME>/snapshot."
	echo "		You can specify the <DIR> to disk if you want to save generated files."
	echo ""
	echo "	-v, --verbose"
	echo "		Print more information."
	echo ""
	echo "	-h, --help"
	echo "		Display this help and exit."
}

function cleanup {
	# umount overlayfs
	if mountpoint -q "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"; then
		umount "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"
	fi

	rm "$PIPE1" >/dev/null 2>&1
	rm "$PIPE2" >/dev/null 2>&1
}
trap cleanup EXIT
trap "ret=$?; cleanup; exit $ret" INT QUIT TERM HUP
set -m # job control


# transform long options to short ones
for arg in "$@"; do
	shift
	case "$arg" in
		"--container-name") set -- "$@" "-n" ;;
		"--user-root")      set -- "$@" "-u" ;;
		"--snapshot-dir")   set -- "$@" "-d" ;;
		"--verbose")        set -- "$@" "-v" ;;
		"--help")           set -- "$@" "-h" ;;
		*)                  set -- "$@" "$arg"
	esac
done

# process options
VERBOSE=false
OPTIND=1
while getopts n:u:d:vh opt; do
	case $opt in
		n)                  CONTAINER_NAME=$OPTARG ;;
		u)                  USER_NAMESPACE_CMD="--user --map-root-user"
		                    USER=$OPTARG ;;
		d)                  SNAPSHOT_DIR=$OPTARG ;;
		v)                  echo "verbose on"
		                    VERBOSE=true ;;
		h)                  help
		                    exit ;;
		?)                  help
		                    exit 2 ;;
	esac
done
shift $(expr $OPTIND - 1)

# check root
if [ $(id -u) -ne 0 ]; then
	echo "need to run as root"
	exit 2
fi

# check positional arguments
if [ -z "$1" ]; then
	echo "nothing to run!" && help && exit 2
fi


#############################################################
# The layer right above rootfs, contains initial settings.
# Do not put empty directory(s) in here unless you know what 
# you are doing as it will cause upper layer to create opaque 
# directory so to furthur complicate merging.
# [LOW] rootfs -> firmware -> snapshot -> dirty [HIGH]
#############################################################
debootstrap_firmware_layer() {
	local firmware_dir="$1"
	mkdir -p "$firmware_dir" >/dev/null 2>&1

	pushd "$firmware_dir" >/dev/null
	mkdir -p "etc"
	echo "nameserver 8.8.8.8" >etc/resolv.conf

	mkdir -p "var"
	ln -s "/run" "var/run"
	popd >/dev/null
}


#############################################################
# Create and mount sandbox's rootfs
# Create all necessary files for sandbox
#############################################################
debootstrap_sandbox() {
	local name="$CONTAINER_NAME"

	mkdir "/tmp$PREFIX_DIR" >/dev/null 2>&1
	pushd "/tmp$PREFIX_DIR" >/dev/null

	SNAPSHOT_DIR=$(realpath -m "$name/$SNAPSHOT_DIR") # to abs path
	[ ! -d "$name" ] && echo "Create new container \"$CONTAINER_NAME\" with snapshot at $SNAPSHOT_DIR"

	# create/load rootfs
	mkdir -p "$name/dirty" >/dev/null 2>&1
	mkdir -p "$name/workdir" >/dev/null 2>&1
	mkdir -p "$name/rootfs" >/dev/null 2>&1
	firmware_dir=$(realpath "$name/firmware") # to abs path
	debootstrap_firmware_layer "$firmware_dir" >/dev/null 2>&1
	cd "$name" # /tmp/sbox/$CONTAINER_NAME
	mkdir -p "$SNAPSHOT_DIR" >/dev/null 2>&1 # create snapshot directory

	if [ ! -z "$(ls -A $SNAPSHOT_DIR)" ]; then
		echo "load previous snapshot from $SNAPSHOT_DIR"
	fi

	# mount rootfs via overlayfs
	# LOW <----------------------------------> HIGH
	# [/] -> [firmware] -> [snapshot_dir] -> [dirty] <= file i/o
	mount -t overlay \
		-o lowerdir="$SNAPSHOT_DIR":"$firmware_dir":/,upperdir="dirty",workdir="workdir" \
		overlay "rootfs"

	popd >/dev/null
}


#############################################################
# Like xargs but works with bash function
#############################################################
xxargs() {
	local flag_t=false
	[ "$1" == "-t" ] && { flag_t=true; shift; }
	local prog="$1"
	shift
	local args=()
	for arg in "$@"; do
		args=("${args[@]}" "\"$arg\"")
	done

	local line
	local ret=true
	while read line; do
		$flag_t && echo "$prog ${args[@]} $line"
		eval "$prog ${args[@]} $line"
		ret=$((ret | $?))
	done
	return $ret
}


#############################################################
# convert an ip address to decimal number.
#############################################################
ip2num() {
	local a b c d
	IFS=. read -r a b c d <<< "$1"
	echo "$(((a << 24) + (b << 16) + (c << 8) + d))"
}


#############################################################
# convert a decimal number to ip address.
#############################################################
num2ip () {
	local a b c d
	a=$(((0xFF000000 & $1) >> 24))
	b=$(((0x00FF0000 & $1) >> 16))
	c=$(((0x0000FF00 & $1) >> 8))
	d=$(((0x000000FF & $1) >> 0))
	echo "$a.$b.$c.$d"
}


#############################################################
# Input a masked ip representing a subnet.
# Output the first and last ips in that subnet.
#############################################################
get_subnet_range() {
	local numeric_output=false
	[ "$1" == "-n" ] && { numeric_output=true; shift; }
	local masked_ip="$1" # eg 10.8.3.1/24

	local arr category addr
	local start end
	mapfile -t arr < <(ipcalc -nb $masked_ip)
	for l in "${arr[@]}"; do
		IFS=' ' read category addr <<< "$l"
		if [[ $category == "Network"* ]]; then
			start=$(echo $addr | sed 's/\/[0-9]\+//')
		elif [[ $category == "Broadcast"* ]]; then
			end=$addr
		elif [[ $category == "Hostroute"* ]]; then
			start=$addr
			end=$addr
		fi
	done

	if $numeric_output; then
		echo "$(ip2num $start) $(ip2num $end)"
	else
		echo "$start $end"
	fi
}


#############################################################
# Get all subnets from system in ip form.
# Output a pair of first and last addresses.
# of spans.
# Arguments:
#     -n       output a pair of numbers instead of ip addr
#############################################################
get_sys_subnets() {
	local flag_n
	[ "$1" == "-n" ] && { flag_n="-n"; shift; }

	ip addr show | pcregrep -io -e '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\/[0-9]+' | \
	while read -r line; do
		local start=""
		local end=""
		local args=($flag_n $line)
		read start end <<< $(get_subnet_range "${args[@]}")
		echo "$start $end"
	done
}




starts=() # global span set
ends=() # global span set

#############################################################
# Perform union operation of the given span against a set of 
# spans.
# Print the union span.
# e.g.,
# union ([2,7], {[1,3], [5,9], [10,15]}) ==> {[1,9], [10,15]}
# Globals:
#     starts
#     ends
#############################################################
spans_union() {
	local s=$1
	local e=$2
	local start end
	local i j
	local len=${#starts[@]}

	start=$s
	for ((i=0; i<len; i++)); do
		if ((s < ${starts[i]})); then
			start=$s
			break
		elif ((s >= ${starts[i]})) && ((s <= ${ends[i]})); then
			start=${starts[$i]}
			break
		fi
	done

	end=$e
	for ((j=0; j<len; j++)); do
		if ((e < ${starts[$j]})); then
			end=$e
			break
		elif ((e >= ${starts[$j]})) && ((e <= ${ends[$j]})); then
			end=${ends[$j]}
			((j++))
			break
		fi
	done

	starts=("${starts[@]:0:$i}" "$start" "${starts[@]:$j}")
	ends=("${ends[@]:0:$i}" "$end" "${ends[@]:$j}")
	echo "$start $end"
}


#############################################################
# Check if a give span intersects with a set of spans.
# Print the end of intersection boundary.
# e.g.,
# intersect ([2,7], {[0,1], [10,15]}) ==> false
# intersect ([2,7], {[0,3], [5,15]}) ==> true
# Globals:
#     starts
#     ends
#############################################################
spans_intersected() {
	local s=$1
	local e=$2
	local len=${#starts[@]}

	for ((i=0; i<len; i++)); do
		if ( ((s >= ${starts[i]})) && ((s <= ${ends[i]})) ) || \
			( ((e >= ${starts[i]})) && ((e <= ${ends[i]})) ) || \
			( ((s < ${starts[i]})) && ((e > ${ends[i]})) ); then
			echo $((e>${ends[i]} ? e : ${ends[i]})) # max
			return 0
		fi
	done
	return 1
}


#############################################################
# Get system subnet range as a pair of numbers.
# Save these range pairs to a global variable by doing the 
# same union operation against that global variable over and
# over.
# Globals:
#     starts
#     ends
#############################################################
save_sys_subnets_as_spans() {
	local l h
	while read -r l h; do
		# echo "set $l $h"
		spans_union $l $h >/dev/null 2>&1
	done < <(get_sys_subnets -n)
}


#############################################################
# Given a starting address and a subnet mask, return the 
# ip address to the next available subnet.
#############################################################
get_avail_subnet_from_sys() {
	local start_ip="$1"
	local subnet_mask="$2"

	local ip_dec=$(ip2num "$start_ip")
	local ip=$start_ip
	while [ $ip_dec -lt 4294967295 ]; do # 0xFFFFFFFF
		ip_next=$(get_subnet_range -n "$ip/$subnet_mask" | xxargs spans_intersected)
		if [ ! -z "$ip_next" ]; then
			ip_dec=$((ip_next + 1))
			ip=$(num2ip $ip_dec)
		else
			ip=$(get_subnet_range "$ip/$subnet_mask" | awk '{print $1}')
			break
		fi
	done
	
	echo "$ip"
}


#############################################################
# Setup network for sandbox.
# Currently using pair-interface but better options do exist.
# Globals:
#     IP_A         pair ip for host
#     IP_B         pair ip for sandbox
#############################################################
IP_A="192.168.50.1" # default
IP_B="192.168.50.2" # default
eth_setup() {
	local p1=$1 # pipe1
	local p2=$2 # pipe2
	fail() {
		local _
		read -t 0.1 _ <$p1
		echo "Error: $1" >$p2
		exit 1
	}

	save_sys_subnets_as_spans # load current network setup
	local subnet_mask=30
	local subnet_ip="$(get_avail_subnet_from_sys "$IP_A" $subnet_mask)" # start searching from default value
	local subnet_ip_dec="$(ip2num $subnet_ip)" # ip to decimal number
	IP_A="$(num2ip $((subnet_ip_dec + 1)))"
	IP_B="$(num2ip $((subnet_ip_dec + 2)))"
	echo "assigned ip $IP_B for sandbox"

	ip link add "veth_$CONTAINER_NAME" type veth peer name "veth0" # veth0 for sandbox
	[ $? -ne 0 ] && fail "Unable to create network interfaces!"
	ip addr add "$IP_A/$subnet_mask" dev "veth_$CONTAINER_NAME" # IP_A - IP_B
	ip link set "veth_$CONTAINER_NAME" up

	# iptables -P FORWARD DROP
	iptables -t nat -A POSTROUTING -s "$IP_A/$subnet_mask" -o eth0 -j MASQUERADE # IP_A - IP_B
	iptables -A FORWARD -i eth0 -o "veth_$CONTAINER_NAME" -j ACCEPT
	iptables -A FORWARD -o eth0 -i "veth_$CONTAINER_NAME" -j ACCEPT

	# wait for sandbox pid
	read unshare_pid <$p1
	rm $p1 # rm $PIPE1
	if [ ! -n "$unshare_pid" ] || [ ! "$unshare_pid" -eq "$unshare_pid" ] 2>/dev/null; then
		fail "Unable to get unshare pid when setting up network!"
	fi
	$VERBOSE && echo "sandbox pid: $unshare_pid"

	# write pid file
	echo $unshare_pid > "/tmp$PREFIX_DIR/$CONTAINER_NAME/container.pid"

	mkdir -p "/var/run/netns" >/dev/null 2>&1
	touch "/var/run/netns/ns_$CONTAINER_NAME"
	mount --bind "/proc/$unshare_pid/ns/net" "/var/run/netns/ns_$CONTAINER_NAME"
	ip link set "veth0" netns "ns_$CONTAINER_NAME" # send veth0 to sandbox
	ip netns exec "ns_$CONTAINER_NAME" ip addr add "$IP_B/$subnet_mask" dev "veth0" # IP_A - IP_B
	ip netns exec "ns_$CONTAINER_NAME" ip link set "veth0" up
	ip netns exec "ns_$CONTAINER_NAME" ip link set lo up
	ip netns exec "ns_$CONTAINER_NAME" ip route add default via "$IP_A" # route all traffic to go through veth
	umount "/var/run/netns/ns_$CONTAINER_NAME"
	rm "/var/run/netns/ns_$CONTAINER_NAME"
	echo "eth_setup() exit" >$p2 # signal main process that we are done
}

debootstrap_sandbox "$CONTAINER_NAME" # create work files
PIPE1=$(mktemp -u) # for receiving namespace pid in task
PIPE2=$(mktemp -u) # for receiving task finish signal
sudo -u $USER mkfifo $PIPE1 $PIPE2
$VERBOSE && echo "eth_setup() start"
(eth_setup $PIPE1 $PIPE2 &) # async


# create new namespace
sudo -u $USER \
unshare --mount --propagation slave \
	--pid --uts --ipc --cgroup 	--net\
	--kill-child $USER_NAMESPACE_CMD \
	--fork \
	bash -c """$(cat <<-EOF
		# send current shell pid to background task
		cat /proc/self/status | grep ^PPid: | awk '{print \$2}' >$PIPE1

		read str <$PIPE2
		if [[ "\$str" == "Error:"* ]]; then
			echo -e "\\e[31m\$str\\e[0m" >&2
			exit 1
		else
			$VERBOSE && echo "\$str"
		fi
		rm $PIPE2

		# mountings
		cd "/tmp$PREFIX_DIR/$CONTAINER_NAME"
		mount -t proc proc rootfs/proc
		mount -t tmpfs tmpfs rootfs/tmp
		mount -t sysfs -r sysfs rootfs/sys
		# mount --rbind -r /sys rootfs/sys # mount if net ns is not present
		mount --rbind /dev rootfs/dev # -r ?
		mount -t tmpfs tmpfs rootfs/run
		# mount --rbind -r /run rootfs/run # this or resolv.conf
		mount --bind \$(readlink -f /etc/resolv.conf) rootfs/etc/resolv.conf

		# display extra info if enters user namespace
		if [ ! -z "$USER_NAMESPACE_CMD" ]; then
			user_inode=$(readlink /proc/self/ns/user | cut -c7-16) # user ns
			echo "enter new user namespace \"\$user_inode\""
			echo "as user \"\$USER\" (\$(id -u \$USER))"
		fi

		echo "Enter container \"$CONTAINER_NAME\": "

		exec chroot rootfs \
			bash -c 'cd ~; exec $@'
		echo "Error: program shouldn't reach here." >&2
		EOF
	)"""

# clean up network
iptables -t nat -D POSTROUTING -s "$IP_A/30" -o eth0 -j MASQUERADE >/dev/null 2>&1
iptables -D FORWARD -i eth0 -o "veth_$CONTAINER_NAME" -j ACCEPT >/dev/null 2>&1
iptables -D FORWARD -o eth0 -i "veth_$CONTAINER_NAME" -j ACCEPT >/dev/null 2>&1
ip link delete "veth_$CONTAINER_NAME" >/dev/null 2>&1

cleanup
trap - EXIT INT QUIT TERM HUP # free traps

#Save snapshot
pushd "/tmp$PREFIX_DIR/$CONTAINER_NAME" >/dev/null

tree -Ca "dirty"
size=$(du -sPh "dirty" | cut -f1-1)
verbose_cmd=$($VERBOSE && echo '--verbose')
echo "$size data generated."
while true; do
	read -p "> Commit changes to snapshot? [Y/n] " -e yn
	case $yn in
		"" | [Yy]* )
			sbox-fstool commit "$CONTAINER_NAME" "$verbose_cmd" \
				--snapshot-dir "$SNAPSHOT_DIR" && \
			echo "commited to $(realpath $SNAPSHOT_DIR)"
			break
			;;
		[Nn]* )
			echo "Abort."
			$VERBOSE && echo "remove $(realpath -m dirty)"
			rm -r "dirty" >/dev/null 2>&1
			exit 0
			;;
		* ) ;;
	esac
done

size=$(du -sPh "$SNAPSHOT_DIR" | cut -f1-1)
file_count=$(find "$SNAPSHOT_DIR" -type f | wc -l)
dir_count=$(find "$SNAPSHOT_DIR" -mindepth 1 -type d | wc -l)
echo "Snapshot size $size ($file_count files, $dir_count directories)."
while true; do
	read -p "> Merge snapshot with local filesystem? [N/y] " -e yn
	case $yn in
		[Yy]* ) 
			sbox-fstool merge "$CONTAINER_NAME" "$verbose_cmd" \
				--snapshot-dir "$SNAPSHOT_DIR" \
				--rootfs-dir '\' && \
			echo "snapshot merged"
			break
			;;
		"" | [Nn]* ) 
			echo "Abort."
			exit
			;;
		* ) ;;
	esac
done

popd >/dev/null
