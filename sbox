#!/bin/bash
#
# sbox
# Run programs in a sandbox environment without writting to rootfs.
#
# This program is NOT a full-fledge container like docker!
# Instead, it is a cut-down version of container, namely a sandbox, designed 
# to allow you to run programs without worrying about polluting your rootfs.
# You may chose to merge the files generated by your program into rootfs 
# once it exits.
# Will run on any platform that can run docker.
#
# Copyright: 2019 Shawwwn, shawwwn1@gmail.com
# License: MIT
#
# Usage: sbox [OPTION] PROGRAM
#
CONTAINER_NAME=default					# default container name
SNAPSHOT_DIR="snapshot"					# default snapshot directory name

USER_NAMESPACE_CMD=""
USER="root"
PREFIX_DIR="/sbox"

function help {
	echo "usage: $0: [OPTION] PROGRAM"
	echo "Run <PROGRAM> in a sandbox environment without writting to rootfs."
	echo ""
	echo "	-n, --container-name NAME"
	echo "		Mount OverlayFS at /tmp/sbox/<NAME>."
	echo "		Default cantainer name is 'default'."
	echo ""
	echo "	-u, --user-root USER"
	echo "		Create user namespace as unprivileged user <USER>,"
	echo "		so that its privileges will be bound by the user."
	echo ""
	echo "	-d, --snapshot-dir DIR"
	echo "		Directory to store files generated by sandboxed program."
	echo "		Default location is /tmp/sbox/<NAME>/snapshot."
	echo "		You can specify the <DIR> to disk if you want to save generated files."
	echo ""
	echo "	-v, --verbose"
	echo "		Print more information."
	echo ""
	echo "	-h, --help"
	echo "		Display this help and exit."
}

function cleanup {
	# umount overlayfs
	if mountpoint -q "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"; then
		umount "/tmp$PREFIX_DIR/$CONTAINER_NAME/rootfs"
	fi

	# release netns
	iptables -t nat -D POSTROUTING -s 192.168.50.1/30 -o eth0 -j MASQUERADE >/dev/null 2>&1
	iptables -D FORWARD -i eth0 -o "veth_$CONTAINER_NAME" -j ACCEPT >/dev/null 2>&1
	iptables -D FORWARD -o eth0 -i "veth_$CONTAINER_NAME" -j ACCEPT >/dev/null 2>&1
	ip link delete "veth_$CONTAINER_NAME" >/dev/null 2>&1

	rm "$PIPE1" >/dev/null 2>&1
	rm "$PIPE2" >/dev/null 2>&1
}
trap cleanup EXIT
trap "ret=$?; cleanup; exit $ret" INT QUIT TERM HUP
set -m # job control


# transform long options to short ones
for arg in "$@"; do
	shift
	case "$arg" in
		"--container-name") set -- "$@" "-n" ;;
		"--user-root")      set -- "$@" "-u" ;;
		"--snapshot-dir")   set -- "$@" "-d" ;;
		"--verbose")        set -- "$@" "-v" ;;
		"--help")           set -- "$@" "-h" ;;
		*)                  set -- "$@" "$arg"
	esac
done


# process options
VERBOSE=false
OPTIND=1
while getopts n:u:d:vh opt; do
	case $opt in
		n)                  CONTAINER_NAME=$OPTARG ;;
		u)                  USER_NAMESPACE_CMD="--user --map-root-user"
		                    USER=$OPTARG ;;
		d)                  SNAPSHOT_DIR=$OPTARG ;;
		v)                  echo "verbose on"
		                    VERBOSE=true ;;
		h)                  help
		                    exit ;;
		?)                  help
		                    exit 2 ;;
	esac
done
shift $(expr $OPTIND - 1)


# check root
if [ $(id -u) -ne 0 ]; then
	echo "need to run as root"
	exit 2
fi

# check positional arguments
if [ -z "$1" ]; then
	echo "nothing to run!" && help && exit 2
fi

#############################################################
# The layer right above rootfs, contains initial settings.
# Do not put empty directory(s) in here unless you know what 
# you are doing as it will cause upper layer to create opaque 
# directory so to furthur complicate merging.
# [LOW] rootfs -> firmware -> snapshot -> dirty [HIGH]
#############################################################
debootstrap_firmware_layer() {
	local firmware_dir="$1"
	mkdir -p "$firmware_dir" >/dev/null 2>&1

	pushd "$firmware_dir" >/dev/null
	mkdir -p "etc"
	echo "nameserver 8.8.8.8" >etc/resolv.conf

	mkdir -p "var"
	ln -s "/run" "var/run"
	popd >/dev/null
}

#############################################################
# Create and mount sandbox's rootfs
# Create all necessary files for sandbox
#############################################################
debootstrap_sandbox() {
	local name="$CONTAINER_NAME"

	mkdir "/tmp$PREFIX_DIR" >/dev/null 2>&1
	pushd "/tmp$PREFIX_DIR" >/dev/null

	# create/load rootfs
	mkdir -p "$name/dirty" >/dev/null 2>&1
	mkdir -p "$name/workdir" >/dev/null 2>&1
	mkdir -p "$name/rootfs" >/dev/null 2>&1
	firmware_dir=$(realpath "$name/firmware") # to abs path
	debootstrap_firmware_layer "$firmware_dir" >/dev/null 2>&1
	cd "$name" # /tmp/sbox/$CONTAINER_NAME
	SNAPSHOT_DIR=$(realpath "$SNAPSHOT_DIR") # to abs path
	if [ ! -d "$SNAPSHOT_DIR" ]; then
		mkdir -p "$SNAPSHOT_DIR" >/dev/null 2>&1 # create snapshot directory
		echo "create new snapshot at $SNAPSHOT_DIR"
	else
		echo "load previous snapshot from $SNAPSHOT_DIR"
	fi

	# mount rootfs via overlayfs
	# LOW <----------------------------------> HIGH
	# [/] -> [firmware] -> [snapshot_dir] -> [dirty] <= file i/o
	mount -t overlay \
		-o lowerdir="$SNAPSHOT_DIR":"$firmware_dir":/,upperdir="dirty",workdir="workdir" \
		overlay "rootfs"

	popd >/dev/null
}

# prep sandbox network
eth_setup() {
	P1=$1
	P2=$2
	ip link add "veth_$CONTAINER_NAME" type veth peer name veth0 # create pair eth
	ip addr add 192.168.50.1/30 dev "veth_$CONTAINER_NAME" # 192.168.50.1 - 192.168.50.2
	ip link set "veth_$CONTAINER_NAME" up

	iptables -t nat -A POSTROUTING -s 192.168.50.1/30 -o eth0 -j MASQUERADE # 192.168.50.1 - 192.168.50.2
	iptables -A FORWARD -i eth0 -o "veth_$CONTAINER_NAME" -j ACCEPT
	iptables -A FORWARD -o eth0 -i "veth_$CONTAINER_NAME" -j ACCEPT

	read unshare_pid <$P1 # wait for sandbox pid
	rm $P1
	if [ ! -n "$unshare_pid" ] || [ ! "$unshare_pid" -eq "$unshare_pid" ] 2>/dev/null; then
		echo "Error: Network setup failed -- unable to get unshare pid!" >&2
		exit 1
	fi
	$VERBOSE && echo "sandbox pid: $unshare_pid"
	mkdir -p "/var/run/netns" >/dev/null 2>&1
	touch "/var/run/netns/ns_$CONTAINER_NAME"
	mount --bind "/proc/$unshare_pid/ns/net" "/var/run/netns/ns_$CONTAINER_NAME"
	ip link set veth0 netns "ns_$CONTAINER_NAME" # send veth0 to sandbox
	ip netns exec "ns_$CONTAINER_NAME" ip addr add 192.168.50.2/30 dev veth0 # 192.168.50.1 - 192.168.50.2
	ip netns exec "ns_$CONTAINER_NAME" ip link set veth0 up
	ip netns exec "ns_$CONTAINER_NAME" ip link set lo up
	ip netns exec "ns_$CONTAINER_NAME" ip route add default via 192.168.50.1 # route all traffic to go through veth0
	umount "/var/run/netns/ns_$CONTAINER_NAME"
	rm "/var/run/netns/ns_$CONTAINER_NAME"
	echo "eth_setup() exit" >$P2 # signal main process that we are done
}


cleanup # clean up last execution (if any)
debootstrap_sandbox "$CONTAINER_NAME" # create work files
PIPE1=$(mktemp -u) # for receiving namespace pid in task
PIPE2=$(mktemp -u) # for receiving task finish signal 
sudo -u $USER mkfifo $PIPE1 $PIPE2
$VERBOSE && echo "eth_setup() start"
(eth_setup $PIPE1 $PIPE2 &) # async


# create new namespace
sudo -u $USER \
unshare --mount --propagation slave \
	--pid --uts --ipc --cgroup 	--net\
	--kill-child $USER_NAMESPACE_CMD \
	--fork \
	bash -c """$(cat <<-EOF
		# send current shell pid to background task
		cat /proc/self/status | grep ^PPid: | awk '{print \$2}' >$PIPE1
		
		# wait for background task to complete (optional)
		read str <$PIPE2
		$VERBOSE && echo "\$str"
		rm $PIPE2

		# mountings
		cd "/tmp$PREFIX_DIR/$CONTAINER_NAME"
		mount -t proc proc rootfs/proc
		mount -t tmpfs tmpfs rootfs/tmp
		mount -t sysfs -r sysfs rootfs/sys
		# mount --rbind -r /sys rootfs/sys # mount if net ns is not present
		mount --rbind /dev rootfs/dev # -r ?
		mount -t tmpfs tmpfs rootfs/run
		# mount --rbind -r /run rootfs/run # this or resolv.conf
		mount --bind \$(readlink -f /etc/resolv.conf) rootfs/etc/resolv.conf

		# display extra info if enters user namespace
		if [ ! -z "$USER_NAMESPACE_CMD" ]; then
			user_inode=$(readlink /proc/self/ns/user | cut -c7-16) # user ns
			echo "enter new user namespace \"\$user_inode\""
			echo "as user \"\$USER\" (\$(id -u \$USER))"
		fi

		echo "Enter container \"$CONTAINER_NAME\": "

		exec chroot rootfs \
			bash -c 'cd ~; exec $@'
		echo "Error: program shouldn't reach here." >&2
		EOF
	)"""

cleanup
trap - EXIT INT QUIT TERM HUP # free traps


#Save snapshot
pushd "/tmp$PREFIX_DIR/$CONTAINER_NAME" >/dev/null

tree -Ca "dirty"
size=$(du -sPh dirty | cut -f1-1)
verbose_cmd=$($VERBOSE && echo '--verbose')
echo "$size data generated."
while true; do
	read -p "> Commit changes to snapshot [y/n]? " -e -i "Y" yn
	case $yn in
		[Yy]* ) 
			sbox-fstool commit "$CONTAINER_NAME" "$verbose_cmd" \
				--snapshot-dir "$SNAPSHOT_DIR" && \
			echo "commited to $(realpath $SNAPSHOT_DIR)"
			break
			;;
		[Nn]* ) exit ;;
		* ) ;;
	esac
done

size=$(du -sPh "$SNAPSHOT_DIR" | cut -f1-1)
file_count=$(find "$SNAPSHOT_DIR" -type f | wc -l)
dir_count=$(find "$SNAPSHOT_DIR" -mindepth 1 -type d | wc -l)
echo "Snapshot size $size ($file_count files, $dir_count directories)."
while true; do
	read -p "> Merge snapshot with local filesystem [y/n]? " -e -i "N" yn
	case $yn in
		[Yy]* ) 
			sbox-fstool merge "$CONTAINER_NAME" "$verbose_cmd" \
				--snapshot-dir "$SNAPSHOT_DIR" \
				--rootfs-dir '\' && \
			echo "snapshot merged"
			break
			;;
		[Nn]* ) exit ;;
		* ) ;;
	esac
done

popd >/dev/null
